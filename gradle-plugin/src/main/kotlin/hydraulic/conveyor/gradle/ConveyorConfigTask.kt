package hydraulic.conveyor.gradle

import dev.hydraulic.types.machines.Machine
import org.gradle.api.DefaultTask
import org.gradle.api.Project
import org.gradle.api.artifacts.Configuration
import org.gradle.api.plugins.JavaApplication
import org.gradle.api.tasks.Internal
import org.jetbrains.compose.ComposeExtension
import org.jetbrains.compose.desktop.DesktopExtension
import org.openjfx.gradle.JavaFXOptions
import java.io.File

/**
 * A base class for tasks that work with generated Conveyor configuration.
 */
abstract class ConveyorConfigTask : DefaultTask() {
    @get:Internal
    internal lateinit var machineConfigs: Map<Machine, Configuration>

    private val hoconForbiddenChars = setOf(
        '$', '"', '{', '}', '[', ']', ':', '=', ',', '+', '#', '`', '^', '?', '!', '@', '*', '&', '\\'
    )

    private fun hasHoconForbiddenChars(str: String) = str.any { it in hoconForbiddenChars }

    private fun quote(str: String) = if (hasHoconForbiddenChars(str))
        "\"" + str.replace("\\", "\\\\") + "\""
    else
        str

    private fun StringBuilder.importFromComposePlugin(project: Project) {
        val composeExt: ComposeExtension = project.extensions.findByName("compose") as? ComposeExtension ?: return
        val desktopExt: DesktopExtension = composeExt.extensions.findByName("desktop") as? DesktopExtension ?: return
        val app = desktopExt.application
        appendLine("app.jvm.main-class = ${app.mainClass}")
        importJVMArgs(app.jvmArgs, project)

        appendLine("app.fsname = " + quote(app.name))
        app.nativeDistributions.description?.let { appendLine("app.description = " + quote(it)) }
        app.nativeDistributions.vendor?.let { appendLine("app.vendor = " + quote(it)) }

        // TODO(low): Import more stuff, including:
        //
        // - Notarization details?
        // - Icons?
    }

    private val runtimeConfigCopy: Configuration = project.configurations.getByName("runtimeClasspath").copyRecursive()

    private fun StringBuilder.importFromJavaFXPlugin(project: Project) {
        val jfxExtension: JavaFXOptions? = project.extensions.findByName("javafx") as? JavaFXOptions
        if (jfxExtension != null) {
            runtimeConfigCopy.dependencies.removeAll { it.group == "org.openjfx" }
            appendLine("include required(\"/stdlib/jvm/javafx/from-jmods.conf\")")
            appendLine("javafx.version = ${jfxExtension.version}")
            appendLine("app.jvm.modules = ${'$'}{app.jvm.modules} " + jfxExtension.modules.joinToString(", ", prefix = "[ ", postfix = " ]"))
        }
    }

    private fun StringBuilder.importFromDependencyConfigurations(project: Project) {
        val crossPlatformDeps: Set<File> = (listOf(runtimeConfigCopy) + machineConfigs.values)
            .map { it.files }
            .filterNot { it.isEmpty() }
            .reduce { left: Set<File>, right: Set<File> -> left.intersect(right) }

        // Emit app JAR input.
        appendLine("app.inputs += " + quote(project.tasks.getByName("jar").outputs.files.singleFile.toString()))
        appendLine()

        // Emit cross-platform JARs.
        appendLine("app.inputs = ${'$'}{app.inputs} [")
        for (entry in crossPlatformDeps.sorted())
            appendLine("    " + quote(entry.toString()))
        appendLine("]")

        // Emit platform specific JARs into the right config sections.
        for ((platform, config) in machineConfigs) {
            if (config.isEmpty) continue
            appendLine()
            appendLine("app.$platform.inputs = ${'$'}{app.$platform.inputs} [")
            for (entry in (config - crossPlatformDeps).sorted())
                appendLine("    " + quote(entry.toString()))
            appendLine("]")
        }
    }

    private fun StringBuilder.importFromJavaPlugin(project: Project) {
        // TODO: Import JVM version and vendor from the toolchain.

        val appExtension = project.extensions.findByName("application") as? JavaApplication
        if (appExtension != null) {
            appendLine("app.jvm.main-class = ${appExtension.mainClass.get()}")
            val jvmArgs = appExtension.applicationDefaultJvmArgs
            importJVMArgs(jvmArgs, project)
        }
    }

    private fun StringBuilder.importJVMArgs(jvmArgs: MutableIterable<String>,
                                            project: Project) {
        val argsNotPointingIntoTree = jvmArgs
            .toList()
            .filterNot { project.rootProject.rootDir.toString() in it }
        if (argsNotPointingIntoTree.isNotEmpty()) {
            appendLine("app.jvm.options = ${'$'}{app.jvm.options} " +
                argsNotPointingIntoTree.joinToString(", ", "[ ", " ]") { '"' + it + '"' })
        }
    }

    protected fun generate(): String {
        return buildString {
            appendLine("// Generated by the Conveyor Gradle plugin.")

            // This strips deps so must run before we calculate dep configurations. Also, we run it early so the import
            // statement is at the top.
            importFromJavaFXPlugin(project)

            if (project.version.toString().isBlank())
                throw Exception("You must set the 'version' property of the project to emit Conveyor configuration.")
            appendLine("app.version = ${project.version}")
            if (project.group.toString().isBlank())
                throw Exception("You must set the 'group' property of the project to emit Conveyor configuration. Some platforms require a reverse DNS name.")
            appendLine("app.rdns-name = ${project.group}.${'$'}{app.fsname}")

            importFromJavaPlugin(project)
            importFromComposePlugin(project)
            importFromDependencyConfigurations(project)
        }
    }
}
