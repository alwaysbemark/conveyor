package hydraulic.conveyor.gradle

import dev.hydraulic.types.machines.Machine
import org.gradle.api.DefaultTask
import org.gradle.api.Project
import org.gradle.api.artifacts.Configuration
import org.gradle.api.plugins.JavaApplication
import org.gradle.api.tasks.Internal
import org.jetbrains.compose.ComposeExtension
import org.jetbrains.compose.desktop.DesktopExtension
import java.io.File

/**
 * A base class for tasks that work with generated Conveyor configuration.
 */
abstract class ConveyorConfigTask : DefaultTask() {
    @get:Internal
    internal lateinit var machineConfigs: Map<Machine, Configuration>

    private val hoconForbiddenChars = setOf(
        '$', '"', '{', '}', '[', ']', ':', '=', ',', '+', '#', '`', '^', '?', '!', '@', '*', '&', '\\'
    )
    private fun hasHoconForbiddenChars(str: String) = str.any { it in hoconForbiddenChars }

    private fun quote(str: String) = if (hasHoconForbiddenChars(str))
        "\"" + str.replace("\\", "\\\\") + "\""
    else
        str

    private fun StringBuilder.importFromComposePlugin(project: Project) {
        val composeExt: ComposeExtension = project.extensions.findByName("compose") as? ComposeExtension ?: return
        val desktopExt: DesktopExtension = composeExt.extensions.findByName("desktop") as? DesktopExtension ?: return
        val app = desktopExt.application
        appendLine("app.jvm.main-class = ${app.mainClass}")
        importJVMArgs(app.jvmArgs, project)

        appendLine("app.fsname = " + quote(app.name))
        app.nativeDistributions.description?.let { appendLine("app.description = " + quote(it)) }
        app.nativeDistributions.vendor?.let { appendLine("app.vendor = " + quote(it))}

        // TODO(low): Import more stuff, including:
        //
        // - JVM version
        // - Notarization details?
        // - Icons?
    }

    private fun StringBuilder.importFromDependencyConfigurations(project: Project) {
        val runtimeConfig = project.configurations.getByName("runtimeClasspath")
        val crossPlatformDeps: Set<File> = (listOf(runtimeConfig) + machineConfigs.values)
            .map { it.files }
            .filterNot { it.isEmpty() }
            .reduce { left: Set<File>, right: Set<File> -> left.intersect(right) }

        // Emit app JAR input.
        appendLine("app.inputs += " + quote(project.tasks.getByName("jar").outputs.files.singleFile.toString()))
        appendLine()

        // Emit cross-platform JARs.
        appendLine("app.inputs = ${'$'}{app.inputs} [")
        for (entry in crossPlatformDeps.sorted())
            appendLine("    " + quote(entry.toString()))
        appendLine("]")

        // Emit platform specific JARs into the right config sections.
        for ((platform, config) in machineConfigs) {
            if (config.isEmpty) continue
            appendLine()
            appendLine("app.$platform.inputs = ${'$'}{app.$platform.inputs} [")
            for (entry in (config - crossPlatformDeps).sorted())
                appendLine("    " + quote(entry.toString()))
            appendLine("]")
        }
    }

    private fun StringBuilder.importFromJavaPlugin(project: Project) {
        val appExtension = project.extensions.findByName("application") as? JavaApplication
        if (appExtension != null) {
            appendLine("app.jvm.main-class = ${appExtension.mainClass.get()}")
            val jvmArgs = appExtension.applicationDefaultJvmArgs
            importJVMArgs(jvmArgs, project)
        }
    }

    private fun StringBuilder.importJVMArgs(jvmArgs: MutableIterable<String>,
                                            project: Project) {
        val argsNotPointingIntoTree = jvmArgs
            .toList()
            .filterNot { project.rootProject.rootDir.toString() in it }
        if (argsNotPointingIntoTree.isNotEmpty()) {
            appendLine("app.jvm.options = ${'$'}{app.jvm.options} " +
                argsNotPointingIntoTree.joinToString(", ", "[ ", " ]") { '"' + it + '"' })
        }
    }

    protected fun generate(): String {
        return buildString {
            appendLine("// Generated by the Conveyor Gradle plugin.")
            appendLine("app.version = ${project.version}")
            appendLine("app.rdns-name = ${project.group}.${'$'}{app.fsname}")

            importFromJavaPlugin(project)
            importFromComposePlugin(project)
            importFromDependencyConfigurations(project)
        }
    }
}
